<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title> Final </title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
    <!-- core three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(10, 1, 2);
camera.lookAt(0, 1, 0);
const controls = new THREE.OrbitControls(camera, renderer.domElement);

// Floor (เปลี่ยนเป็นวงกลม)
const textureLoader = new THREE.TextureLoader();
const floorTexture = textureLoader.load('https://raw.githubusercontent.com/Pongpanot99/final.github.io/main/p1.jpg');
floorTexture.wrapS = THREE.RepeatWrapping;
floorTexture.wrapT = THREE.RepeatWrapping;
floorTexture.repeat.set(4, 4); 

const floorGeometry = new THREE.CircleGeometry(12, 64);
const floorMaterial = new THREE.MeshStandardMaterial({ 
  map: floorTexture,
  roughness: 0.0
});
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);
floor.position.set(0, 0.31, 0);

const pillarHeight = 0.3; // ความสูงเสา
const pillarGeometry = new THREE.CylinderGeometry(12, 12, pillarHeight, 64);
const pillarMaterial = new THREE.MeshStandardMaterial({
  color: 0x8B4513, // สีของเสา
  roughness: 0.6
});
const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
pillar.position.y = pillarHeight / 2; // วางเสาให้รับพื้น
scene.add(pillar);

// ----------- พื้นน้ำ (วงกลมใหญ่) -----------
const floor2 = new THREE.CircleGeometry(20, 128, 0, Math.PI * 2);
floor2.rotateX(-Math.PI / 2);

const floorMaterial2 = new THREE.MeshStandardMaterial({
  color: 0x1e90ff, // สีฟ้า
  metalness: 0.6,
  roughness: 0.3,
  side: THREE.DoubleSide,
  flatShading: false,
});

const floor22 = new THREE.Mesh(floor2, floorMaterial2);
floor22.receiveShadow = true;
scene.add(floor22);
floor22.position.set(0, -0.5, 0); // ↓ ลดลงหน่อย เพื่อไม่ให้ทับพื้นดิน

// ----------- คลื่นน้ำด้วย sin -----------
const position = floor2.attributes.position; // ✅ เปลี่ยนจาก floorGeometry → floor2
const vertexCount = position.count;
const originalPositions = position.array.slice(); // เก็บตำแหน่งเริ่มต้น

function animateWater(time) {
  const t = time * 0.0001;
  for (let i = 0; i < vertexCount; i++) {
    const x = originalPositions[i * 3];
    const z = originalPositions[i * 3 + 2];
    const waveHeight = Math.sin(x * 0.3 + t * 2) * Math.cos(z * 0.3 + t * 2) * (0.5 + Math.random() * 0.05);
    position.setY(i, waveHeight);
  }
  position.needsUpdate = true;
  requestAnimationFrame(animateWater);
}
requestAnimationFrame(animateWater);

const material2 = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, metalness: 0.9, roughness: 0.2 });
const glassMaterial = new THREE.MeshPhysicalMaterial({color: 0xffffff,metalness: 0,roughness: 0,transmission: 1.0,
  transparent: true,opacity: 1.0,ior: 1.5,thickness: 0.5,clearcoat: 1.0,clearcoatRoughness: 0 });


  // โหลดโมเดลหลัก
  const gltfLoader = new THREE.GLTFLoader();
  gltfLoader.load("https://raw.githubusercontent.com/Pongpanot99/final.github.io/main/colos2.glb", function(gltf) {
    const model = gltf.scene;
    model.scale.set(1.0, 1.0, 1.0);
    model.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
    scene.add(model);
    model.position.set(0, 0.45, 0)
  });

const loader = new THREE.OBJLoader();
        loader.load('https://raw.githubusercontent.com/Pongpanot99/final.github.io/main/name.obj', function (object2) {
            object2.castShadow = true; // ✅ วัตถุนี้สร้างเงา
            // ตั้งค่า castShadow กับทุก mesh ใน object
            object2.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.material = material2 ;
                }
            });
            object2.scale.set(0.5, 0.5, 0.5);
            object2.rotation.set(0,8,0);
            object2.position.set(0, 0.8, 0)
            scene.add(object2);
            
        }, undefined, function (error) {
            console.error('Error loading OBJ:', error);
        });

//Light
const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.9);
directionalLight.position.set(10, 5, 10);
directionalLight.castShadow = true;
scene.add(directionalLight);

// HDRI
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

new THREE.RGBELoader()
  .setDataType(THREE.UnsignedByteType)
  .load(
    'https://raw.githubusercontent.com/Pongpanot99/final.github.io/main/puresky_2k.hdr',
    (hdrTexture) => {
      const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
      scene.background = envMap;
      scene.environment = envMap;
      hdrTexture.dispose();
      pmremGenerator.dispose();
    }
  );

function animate() {
  
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
